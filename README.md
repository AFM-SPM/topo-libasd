__This project is now in progress. These features might change in future release.__

# libasd

A C++ header-only library to read a .asd file generated by high-speed AFM.

libasd has a binding to python3.

## Usage in Python3

### Building Python Library

WIP

### Example Code

WIP

### With NumPy

WIP

## Usage in C++

You can read the data with the code described below.

```cpp
#include <libasd/libasd.hpp>
#include <fstream>
#include <iostream>

int main()
{
    std::ifstream ifs("example.asd");
    const auto data = asd::read_asd<double>(ifs); // set real type for the data

    std::cout << "x_pixel = " << data.header.x_pixel << '\n';
    std::cout << "y_pixel = " << data.header.y_pixel << '\n';

    for(auto const& frame : data.frames)
    {
        for(auto const& line : frame)
        {
            for(auto const& pixel : line)
            {
                std::cout << pixel; // height [nm] for topography, ...
            }
            std::cout << '\n';
        }
        std::cout << "\n\n";
    }
    std::cout << std::flush;
    return 0;
}
```

Here you can access each frame, line, and pixel intuitively by using range-based
for loops.

You can set file version and channel as a template parameter.

```cpp
const auto data = asd::read_asd<double, asd::ch<2>, asd::ver<0>>(ifs);
```

By default, these are set as channel 1, version 1 respectively.

You can access to each pixel by index instead of range-based for loops.

```cpp
    const std::size_t x_pixel = data.header.x_pixel;
    const std::size_t y_pixel = data.header.y_pixel;
    for(const auto& frame : data.frames)
    {
        for(std::size_t y=0; y<y_pixel; ++y)
        {
            for(std::size_t x=0; x<x_pixel; ++x)
            {
                std::cout << data[y][x]; // note: not [x][y].
            }
            std::cout << '\n';
        }
        std::cout << "\n\n";
    }
```

Be careful with the order of index. `Frame[y]` returns a `Line` at y.
So first you must specify `y` value of the pixel, not `x`.

### How to access the data?

See documents.

### I don't want to use streams. What can I do?

You can pass a `char const*` to `read_asd` function in exactly the same way as streams.

### I need only file-header information. Frame data are not needed.

libasd provides `asd::read_header` function.
It reads only file-header information.
You can use this function in the same way as `read_asd`.

```cpp
#include <libasd/libasd.hpp>
#include <fstream>
#include <iostream>

int main()
{
    std::ifstream ifs("example.asd");
    const auto data = asd::read_header<asd::ver<1>, asd::ch<1>>(ifs);
    return 0;
}
```

Note: It simply ignore the channel information because header format does not
depend on channel number. You can set channel number as unrealistic value here,
but it is not recommended because it is confusing.

### How it contains data?

You may think that libasd contains a frame as an array of arrays.

```cpp
typedef std::int16_t            pixel_type;
typedef std::vector<pixel_type> line_type;
typedef std::vector<line_type>  frame_type;
```

You might be afraid of the performance loss that is owing to a cache-miss
while you access to each line. But it is __not__ true.
Although the usage is easy, you don't have to be afraid of the performance cost.
Libasd contains frames as a single array, not an array of arrays.

```cpp
typedef std::int16_t            pixel_type;
typedef std::vector<pixel_type> frame_type;
```

To make the usage easier, libasd provides a proxy class to access each lines.
It wraps frame class and enable you to access a particular line as a container.
In range-based for loops, this proxy classes are used instead of
`std::vector<pixel_type>::(const_)iterator`.

You can use `std::vector<pixel_type>::(const_)iterator` if you want.

```cpp
const auto frame = data.frames.front();
for(auto iter = frame.raw_begin(), iend = frame.raw_end(); iter != iend; ++iter)
{
    std::cerr << *iter << ' ';
}
```

### Can I use my awesome container with libasd?

If you implemented or found a container or an allocator that has a great feature,
you may want to use it with libasd instead of `std::vector<T, std::allocator<T>>`.

In libasd, you can specify the container used in the classes by passing the
specialized `struct container_dispatcher` as a template parameter.

For example, `asd::container::vec` that is used by default is defined as follows.

```cpp
namespace asd {
namespace container {
struct vec
{
    template<typename T>
    struct rebind
    {
        typedef std::vector<T, std::allocator<T>> other;
    };
};

template<typename T, typename Alloc>
struct container_traits<std::vector<T, Alloc>>
{
    using ptr_accessibility = std::true_type;
    using value_type = T;
};

} // container
} // asd
```

libasd uses the container to declare the container in this way.

```cpp
typedef typename vec::template rebind<int>::other int_array;
```

The struct `container_traits` provides a tag to resolve overload of utility
functions. When the container has an interface to access a pointer that points
the first element and the container can be accessed as a traditional C-array,
it become `std::true_type`, otherwise, `std::false_type`.

Additionally, to deal with different interfaces of containers, libasd has
some helper functions. If it is needed(the container has a different interface
from standard containers), you should overload these functions.

```cpp
// example: add overload for std::vector.

namespace asd {
namespace container {

template<typename T, typename Alloc>
inline T const* get_ptr(const std::vector<T, Alloc>& v) noexcept
{
    return v.data();
}
template<typename T, typename Alloc>
inline std::size_t size(const std::vector<T, Alloc>& v) noexcept
{
    return v.size();
}
template<typename T, typename Alloc>
inline void resize(std::vector<T, Alloc>& v, const std::size_t N)
{
    return v.resize(N);
}
template<typename T, typename Alloc>
inline void clear(std::vector<T, Alloc>& v)
{
    return v.clear();
}

} // container
} // asd
```

After implementing and passing these structs and functions(if necessary),
you can use your awesome container/allocator class with libasd.

By default, `asd::container::vec` and `asd::container::deq` are defined in
`libasd/container_dispatcher.hpp`.
They are corresponds to `std::vector` and `std::deque`, respectively.
It should be noted that only randomly accessible containers can be used with
libasd.

Additionally, you can find `asd::container::boost_vec`,
`asd::container::boost_static_vec`, `asd::container::boost_small_vec`
and `asd::container::boost_deq` in the file
`libasd/boost/container_dispatcher.hpp`.
It is not included by default, but you can manually include this file.
Then you can use containers provided by the Boost.Container library if you
already installed it.

## Documents

WIP

## Licensing terms

Author
- Toru Niina

This product is licensed under the terms of the [MIT License](LICENSE).

- Copyright (c) 2017 Toru Niina

All rights reserved.
